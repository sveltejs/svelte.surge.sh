<svelte:window on:keydown="handleKeydown(event)" />

<div class='app-controls'>
	<div class='icon' style='position: relative; width: 3.2rem; margin-top:-.5rem'>
		<Icon name='menu' />
	</div>

	<ExampleSelector {examples} bind:name on:select />

	<div style='flex: 1 0 auto' />
	<div style='text-align: right; margin-right:.8rem'>
		{#if $user}
		<UserMenu />
		{:else}
		<a class='icon' on:click='login(event)' href='auth/login' title='Login to save'>
			<Icon name='log-in' />
		</a>
		{/if}

		<a class='icon' on:click='$set({ zenMode: !$zenMode })' title='fullscreen editor'>
			{#if $zenMode}
			<Icon name='close' />
			{:else}
			<Icon name='maximize' />
			{/if}
		</a>

		<a class='icon' disabled={downloading} on:click='download()' title='download zip file'>
			<Icon name='download' />
		</a>

		{#if $user}
		<a class='icon' disabled={saving || !$user} on:click='fork()' title='fork'>
			{#if justForked}
			<Icon name='check' />
			{:else}
			<Icon name='git-branch' />
			{/if}
		</a>

		<a class='icon' disabled={saving || !$user} on:click='save()' title='save'>
			{#if justSaved}
			<Icon name='check' />
			{:else}
			<Icon name='save' />
			{/if}
		</a>
		{/if}

		{#if gist}
		<a class='icon' href='{gist.html_url}' title='link to gist'>
			<Icon name='save' />
		</a>
		{/if}
	</div>
</div>

<style>
	.app-controls {
		display: flex;
		align-items: center;
		justify-content: space-between;
		width: 100%;
		padding: .6rem var(--side-nav);
		background-color: var(--second);
		color: white;
		height: 5.6rem;
	}

	.icon {
		padding: 0 .8rem;
		opacity: .5;
		transition: opacity .3s;
	}

	.icon:hover    { opacity: 1 }
	.icon:disabled { opacity: .3 }
	
	.icon[title^='fullscreen'] { display: none }

	@media (min-width: 768px) {
		.icon[title^='fullscreen'] { display: inline }
	}

</style>

<script>
	import ExampleSelector from './ExampleSelector.html';
	import UserMenu from './UserMenu.html';
	import doNotZip from 'do-not-zip';
	import downloadBlob from '../_utils/downloadBlob.js';

	const isMac = typeof navigator !== 'undefined' && navigator.platform === 'MacIntel';

	function wait(ms) {
		return new Promise(f => setTimeout(f, ms));
	}

	export default {
		components: {
			ExampleSelector,
			UserMenu,
			Icon: '../../../components/icon.html', // is this bad practise?
		},

		computed: {
			canSave: ({ $user, gist }) => {
				if (!$user) return false;
				if (!gist) return false;
				return $user.id == gist.owner.id; // comparing number and string
			}
		},

		methods: {
			handleKeydown(event) {
				if (event.which === 83 && (isMac ? event.metaKey : event.ctrlKey)) {
					event.preventDefault();
					this.save();
				}
			},

			login(event) {
				event.preventDefault();
				const loginWindow = window.open(`${window.location.origin}/auth/login`, 'login', 'width=600,height=400');

				const handleLogin = event => {
					loginWindow.close();
					this.store.set({ user: event.data.user });
					window.removeEventListener('message', handleLogin);
				};

				window.addEventListener('message', handleLogin);
			},

			async fork(intentWasSave) {
				const { user } = this.store.get();
				if (!user) return;

				const { name, components, json5 } = this.get();

				this.set({ saving: true });

				try {
					const r = await fetch(`gist/create`, {
						method: 'POST',
						credentials: 'include',
						body: JSON.stringify({
							name,
							components,
							json5
						})
					});

					if (r.status < 200 || r.status >= 300) {
						const { error } = await r.json();
						throw new Error(`Received an HTTP ${r.status} response: ${error}`);
					}

					const gist = await r.json();
					this.fire('forked', { gist });

					this.set({ [intentWasSave ? 'justSaved' : 'justForked']: true });
					await wait(600);
					this.set({ [intentWasSave ? 'justSaved' : 'justForked']: false });
				} catch (err) {
					if (navigator.onLine) {
						alert(err.message);
					} else {
						alert(`It looks like you're offline! Find the internet and try again`);
					}
				}

				this.set({ saving: false });
			},

			async save() {
				const { name, components, json5, gist, saving, canSave } = this.get();

				if (saving) return;

				if (!canSave) {
					this.fork(true);
					return;
				}

				this.set({ saving: true });

				try {
					const files = {};

					// null out any deleted files
					const set = new Set(components.map(m => `${m.name}.${m.type}`));
					Object.keys(gist.files).forEach(file => {
						if (/\.(html|js)$/.test(file)) {
							if (!set.has(file)) files[file] = null;
						}
					});

					components.forEach(module => {
						const file = `${module.name}.${module.type}`;

						if (!gist.files[files] || module.source !== gist.files[file].content) {
							files[file] = { content: module.source };
						}
					});

					if (!gist.files['data.json5'] || json5 !== gist.files['data.json5'].content) {
						files['data.json5'] = { content: json5 };
					}

					// data.json has been deprecated in favour of data.json5
					if (gist.files['data.json']) gist.files['data.json'] = null;

					const r = await fetch(`gist/${gist.id}`, {
						method: 'PATCH',
						credentials: 'include',
						body: JSON.stringify({
							description: name,
							files
						})
					});

					if (r.status < 200 || r.status >= 300) {
						const { error } = await r.json();
						throw new Error(`Received an HTTP ${r.status} response: ${error}`);
					}

					const result = await r.json();

					this.set({ justSaved: true });
					await wait(600);
					this.set({ justSaved: false });
				} catch (err) {
					if (navigator.onLine) {
						alert(err.message);
					} else {
						alert(`It looks like you're offline! Find the internet and try again`);
					}
				}

				this.set({ saving: false });
			},

			async download() {
				this.set({ downloading: true });

				const { bundle, components, data } = this.get();
				const files = await (await fetch('/svelte-app.json')).json();

				if (bundle.imports.length > 0) {
					const idx = files.findIndex(({ path }) => path === 'package.json');
					const pkg = JSON.parse(files[idx].data);
					const deps = {};
					bundle.imports.forEach(mod => {
						const match = /^(@[^\/]+\/)?[^@\/]+/.exec(mod);
						deps[match[0]] = 'latest';
					});
					pkg.dependencies = deps;
					files[idx].data = JSON.stringify(pkg, null, '  ');
				}

				files.push(...components.map(component => ({ path: `src/${component.name}.${component.type}`, data: component.source })));
				files.push({
					path: `src/main.js`, data: `import App from './App.html';

var app = new App({
	target: document.body,
	data: ${JSON.stringify(data, null, '\t').replace(/\n/g, '\n\t')}
});

export default app;` });

				downloadBlob(doNotZip(files), 'svelte-app.zip');

				this.set({ downloading: false });
			}
		}
	};
</script>